    {{range .KeyFields}}
    register<bit<32>>(32w{{$.TableSize}}) regK_{{$.StageName}}_{{.}};{{end}}
    {{range .ValueFields}}
    register<bit<32>>(32w{{$.TableSize}}) regV_{{$.StageName}}_{{.}};{{end}}

    // Using register regKeys, regValues.
    action groupby_{{.StageName}}(inout Key_{{.StageName}} evictedKey, inout Value_{{.StageName}} evictedValue) {
        Value_{{.StageName}} defaultValue = {{.DefaultValueDefinition}};
        Key_{{.StageName}} defaultKey = {{$.DefaultKeyDefinition}};
        // Populate key fields from the current packet.
        Key_{{.StageName}} inKey = {{.DefaultKeyDefinition}};
        {{range $i, $field := $.KeyFields}}
        inKey.{{$field}} = {{index $.KeySourceFields $i}};{{end}}
        // _foundKey_* are the fields that exist in the computed hash bucket.
        {{range .KeyFields}}
        bit<32> _foundKey_{{.}} = 0;{{end}}

        bit<32> hsh = 32w1;
        hash(hsh, HashAlgorithm.crc32, 32w0, inKey, 32w{{.TableSize}});
        {{range .ValueFields}}
        bit<32> _foundValue_{{.}} = 0;{{end}}
        {{range $i, $kf := .KeyFields}}
        regK_{{$.StageName}}_{{$kf}}.read(_foundKey_{{index $.KeyFields $i}}, hsh);{{end}}
        {{range $i, $vf := .ValueFields}}
        regV_{{$.StageName}}_{{$vf}}.read(_foundValue_{{index $.ValueFields $i}}, hsh);{{end}}
        // Determine whether inKey and foundKey are the same key.
        bool same = true;{{range .KeyFields}}
        same = (_foundKey_{{.}} == inKey.{{.}}) ? same : false;{{end}}
        // Determine if foundKey is 0.
        bool zero = true;{{range .KeyFields}}
        zero = (_foundKey_{{.}} == 0) ? zero : false;{{end}}
        
        Value_{{.StageName}} val = {{.DefaultValueDefinition}};
        // There is no eviction if either foundKey == inKey or foundKey == 0.
        bool ok = same || zero;
        {{range .KeyFields}}
        evictedKey.{{.}} = !ok ? _foundKey_{{.}} : 0;{{end}}
        {{range .ValueFields}}
        evictedValue.{{.}} = !ok ? _foundValue_{{.}} : 0;{{end}}
        {{range .ValueFields}}
        bit<32> _val_{{.}} = ok ? _foundValue_{{.}} : 0;{{end}}
        
        // Execute code that updates value registers. The code should reference values by their
        // _val_* variable names directly.
        {{.UpdateCode}}

        // Write the new key and value into the register. Note that we still write inKey even if it was
        // identical to foundKey (since bmv2 doesn't allow conditional method calls).
        {{range $i, $kf := .KeyFields}}
        regK_{{$.StageName}}_{{$kf}}.write(hsh, inKey.{{index $.KeyFields $i}});{{end}}
        {{range $i, $vf := .ValueFields}}
        regV_{{$.StageName}}_{{$vf}}.write(hsh, _val_{{index $.ValueFields $i}});{{end}}
    }
